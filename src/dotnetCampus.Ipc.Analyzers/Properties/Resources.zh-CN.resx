<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DIPC001" xml:space="preserve">
    <value>IPC 未知错误</value>
  </data>
  <data name="DIPC001_Message" xml:space="preserve">
    <value>生成 IPC 代理和对接代码时遇到未知错误：{0}</value>
  </data>
  <data name="DIPC002" xml:space="preserve">
    <value>未指定 IPC 契约类型</value>
  </data>
  <data name="DIPC002_Message" xml:space="preserve">
    <value>指定 IpcPublic 特性时，必须指定契约类型作为第一个参数。</value>
  </data>
  <data name="DIPC003" xml:space="preserve">
    <value>IPC 契约类型必须是接口</value>
  </data>
  <data name="DIPC003_Message" xml:space="preserve">
    <value>IPC 契约类型必须是接口，但 {0} 不是。</value>
  </data>
  <data name="DIPC004" xml:space="preserve">
    <value>IPC 契约类型与实现的接口不匹配</value>
  </data>
  <data name="DIPC004_Message" xml:space="preserve">
    <value>IpcPublic 标记的契约类型是 {1}，但是 {0} 却并没有实现这个接口。</value>
  </data>
  <data name="DIPC010" xml:space="preserve">
    <value>无法生成 IPC 代理</value>
  </data>
  <data name="DIPC010_Message" xml:space="preserve">
    <value>因为当前程序集中没有此 IPC 契约类型（{0}）的实现，因此你必须显式指定一个 IPC 实现或傀儡来辅助生成代理。</value>
  </data>
  <data name="DIPC011" xml:space="preserve">
    <value>IPC 契约类型与代理类型不匹配</value>
  </data>
  <data name="DIPC011_Message" xml:space="preserve">
    <value>获取 IPC 代理时，要获取的契约类型 {0} 与实现或傀儡标记的 IPC 契约类型 {1} 不匹配。</value>
  </data>
  <data name="DIPC012" xml:space="preserve">
    <value>IPC 契约类型与对接类型不匹配</value>
  </data>
  <data name="DIPC012_Message" xml:space="preserve">
    <value>设置 IPC 对接时，要设置的契约类型 {0} 与实现 {2} 标记的 IPC 契约类型 {1} 不匹配。</value>
  </data>
  <data name="DIPC020" xml:space="preserve">
    <value>IPC 类型只支持方法和属性</value>
  </data>
  <data name="DIPC020_Message" xml:space="preserve">
    <value>不支持的 IPC 类型成员 {0}。IPC 类型只支持方法和属性。</value>
  </data>
  <data name="DIPC021" xml:space="preserve">
    <value>IPC 对象不支持事件成员</value>
  </data>
  <data name="DIPC021_Message" xml:space="preserve">
    <value>IPC 对象不支持事件成员 {0}。</value>
  </data>
  <data name="DIPC022" xml:space="preserve">
    <value>IPC 类型不支持只写属性</value>
  </data>
  <data name="DIPC022_Message" xml:space="preserve">
    <value>不支持的 IPC 属性 {0}。IPC 类型只支持读写属性或只读属性。</value>
  </data>
  <data name="DIPC101" xml:space="preserve">
    <value>建议设置 IgnoresIpcException 属性</value>
  </data>
  <data name="DIPC101_Fix1" xml:space="preserve">
    <value>此类型忽略 IPC 连接和超时异常</value>
  </data>
  <data name="DIPC101_Fix2" xml:space="preserve">
    <value>此类型允许抛出 IPC 连接和超时异常</value>
  </data>
  <data name="DIPC101_Message" xml:space="preserve">
    <value>为了更好的可读性，建议设置 IgnoresIpcException 以便开发者知道这里原本是存在 IPC 异常的。</value>
  </data>
  <data name="DIPC102" xml:space="preserve">
    <value>IPC 超时时间不可设为负数</value>
  </data>
  <data name="DIPC102_Message" xml:space="preserve">
    <value>IPC 超时时间不可设为负数，但这里被设为 {0} 毫秒。</value>
  </data>
  <data name="DIPC103" xml:space="preserve">
    <value>超时时间为零</value>
  </data>
  <data name="DIPC103_Message" xml:space="preserve">
    <value>0 毫秒的超时时间相当于不设置超时，因此不需要设置此属性。</value>
  </data>
  <data name="DIPC120" xml:space="preserve">
    <value>IPC 默认值不起作用</value>
  </data>
  <data name="DIPC120_Fix1" xml:space="preserve">
    <value>去掉此成员的 IPC 默认值</value>
  </data>
  <data name="DIPC120_Fix2" xml:space="preserve">
    <value>忽略此成员抛出的 IPC 连接和超时异常</value>
  </data>
  <data name="DIPC120_Message" xml:space="preserve">
    <value>不需要设置默认值。IPC 默认值仅在忽略了 IPC 连接和超时异常的情况下才会生效。</value>
  </data>
  <data name="DIPC121" xml:space="preserve">
    <value>空的 {0} 没有任何用途</value>
  </data>
  <data name="DIPC121_Fix" xml:space="preserve">
    <value>删除 {0}</value>
  </data>
  <data name="DIPC121_Message" xml:space="preserve">
    <value>空的 {0} 没有任何用途，因此完全可以将其删除。</value>
  </data>
  <data name="DIPC122" xml:space="preserve">
    <value>推荐设置 WaitsVoid 属性</value>
  </data>
  <data name="DIPC122_Message" xml:space="preserve">
    <value>在 IPC 访问中难以得知 void 方法调用时是否会等待其返回。虽然默认是不等待，但仍建议显式设置 WaitsVoid 属性以增强此代码的可读性。</value>
  </data>
  <data name="DIPC123" xml:space="preserve">
    <value>不需要设置 IsReadonly 属性</value>
  </data>
  <data name="DIPC123_Message" xml:space="preserve">
    <value>不需要设置 IsReadonly 属性为 false，因为默认如此。</value>
  </data>
  <data name="DIPC124" xml:space="preserve">
    <value>默认值类型与属性类型不匹配</value>
  </data>
  <data name="DIPC124_Message" xml:space="preserve">
    <value>IPC 默认值 {0} 与 {1} 属性的类型不匹配。</value>
  </data>
  <data name="DIPC125" xml:space="preserve">
    <value>默认值类型与方法返回值类型不匹配</value>
  </data>
  <data name="DIPC125_Message" xml:space="preserve">
    <value>IPC 默认值 {0} 与 {1} 方法的返回值类型不匹配。</value>
  </data>
  <data name="DIPC126" xml:space="preserve">
    <value>void 方法的 IPC 默认值不起作用</value>
  </data>
  <data name="DIPC126_Message" xml:space="preserve">
    <value>{0} 方法没有返回值，因此无需设置其 IPC 默认值。</value>
  </data>
  <data name="DIPC127" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="DIPC127_Message" xml:space="preserve">
    <value>试图将 object 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段，如需使用字符串，请修改为“@"""{0}"""”。</value>
  </data>
  <data name="DIPC128" xml:space="preserve">
    <value>字符串将被编译为代码片段</value>
  </data>
  <data name="DIPC128_Message" xml:space="preserve">
    <value>试图将 {1} 类型的默认值设置为代码片段 {0}。请注意，这里的字符串将被编译为代码片段。</value>
  </data>
  <data name="DIPC129" xml:space="preserve">
    <value>字符串编译的代码片段无法被解析</value>
  </data>
  <data name="DIPC129_Message" xml:space="preserve">
    <value>字符串中的代码片段 {0} 在当前上下文下无法被解析。</value>
  </data>
  <data name="DIPC130" xml:space="preserve">
    <value>WaitsVoid 不起作用</value>
  </data>
  <data name="DIPC130_Message" xml:space="preserve">
    <value>方法 {0} 有返回值，因此 WaitsVoid 对其不起作用。</value>
  </data>
</root>